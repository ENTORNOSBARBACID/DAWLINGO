[
  {
    "id": 1,
    "titulo": "Variables-y-Tipos-de-Datos",
    "contenido": "Las variables en Python son contenedores donde se almacenan datos que pueden cambiar durante la ejecución del programa. Una variable tiene un nombre (identificador) y un valor asignado.\n\nPython es un lenguaje de tipado dinámico, lo que significa que no es necesario declarar el tipo de una variable explícitamente; el intérprete detecta el tipo automáticamente según el valor asignado.\n\n### Tipos de datos básicos:\n\n- **int (enteros):** Números sin parte decimal, positivos o negativos. Ejemplo: `edad = 25`, `temperatura = -10`.\n- **float (flotantes):** Números con decimales. Ejemplo: `pi = 3.14159`, `precio = 19.99`.\n- **str (cadenas de texto):** Secuencias de caracteres encerrados en comillas simples (' ') o dobles (\" \"). Ejemplo: `nombre = 'Ana'`, `mensaje = \"Hola Mundo\"`.\n- **bool (booleanos):** Valores de verdad, solo pueden ser `True` o `False`. Se usan para decisiones lógicas.\n\n### Operaciones comunes con variables:\n- Puedes reasignar valores a las variables tantas veces como quieras.\n- Se puede usar la función `type()` para saber el tipo actual de una variable.\n\n### Reglas para nombrar variables:\n- El nombre debe comenzar con una letra o guion bajo (_).\n- Puede contener letras, números y guiones bajos.\n- No usar palabras reservadas del lenguaje (como `if`, `for`, `def`).\n- Deben ser descriptivas para mejorar la legibilidad, por ejemplo: `total_ventas` es mejor que `x`.\n\n### Ejemplos:\n```python\nnombre = 'Juan'\nedad = 30\naltura = 1.75\nactivo = True\nprint(type(nombre))  # <class 'str'>\n```\n\nEntender bien los tipos de datos es fundamental para manipular información correctamente y evitar errores durante la ejecución del programa."
  },
  {
    "id": 2,
    "titulo": "Operadores",
    "contenido": "Los operadores son símbolos que permiten realizar operaciones sobre uno o más operandos (variables o valores). Python ofrece distintos tipos de operadores para manipular datos:\n\n### 1. Operadores aritméticos\nPermiten realizar cálculos matemáticos básicos:\n- `+` Suma: `a + b`\n- `-` Resta: `a - b`\n- `*` Multiplicación: `a * b`\n- `/` División (resultado siempre float): `a / b`\n- `//` División entera (resultado truncado): `a // b`\n- `%` Módulo o resto: `a % b`\n- `**` Potencia: `a ** b`\n\n### 2. Operadores de comparación\nSirven para comparar valores y devuelven `True` o `False`:\n- `==` Igual a\n- `!=` Diferente de\n- `>` Mayor que\n- `<` Menor que\n- `>=` Mayor o igual que\n- `<=` Menor o igual que\n\n### 3. Operadores lógicos\nSe utilizan para combinar expresiones booleanas:\n- `and` (y): ambas condiciones deben ser verdaderas para devolver `True`.\n- `or` (o): devuelve `True` si al menos una condición es verdadera.\n- `not` (no): invierte el valor lógico.\n\n### Ejemplos prácticos:\n```python\nx = 10\ny = 5\nprint(x + y)  # 15\nprint(x > y)  # True\nprint(x < y or y == 5)  # True\nprint(not(x == y))  # True\n```\n\n### Importancia\nLos operadores son la base para construir condiciones, realizar cálculos y controlar el flujo del programa mediante estructuras como `if`, `while`, y `for`. Saber usarlos correctamente es crucial para programar con eficacia."
  },
  {
    "id": 3,
    "titulo": "Entrada-y-Salida-de-Datos",
    "contenido": "La interacción con el usuario es una parte fundamental de muchos programas. Python ofrece funciones sencillas para recibir datos del usuario y mostrar resultados.\n\n### Salida: `print()`\nLa función `print()` muestra información en la consola. Puede imprimir texto, variables o resultados de expresiones.\n\n- Se pueden imprimir múltiples valores separados por comas; Python los separa con espacios automáticamente.\n- También se puede usar formato con f-strings para mayor claridad:\n\n```python\nnombre = 'Lucía'\nedad = 28\nprint('Hola', nombre, 'tienes', edad, 'años.')\nprint(f'Hola {nombre}, tienes {edad} años.')\n```\n\n### Entrada: `input()`\nEsta función detiene la ejecución del programa esperando que el usuario escriba algo y presione Enter.\n\n- El valor introducido siempre se recibe como cadena de texto (`str`).\n- Si se espera otro tipo (como un número), hay que convertirlo explícitamente.\n\n```python\nnombre = input('¿Cómo te llamas? ')\nedad = int(input('¿Cuántos años tienes? '))\nprint(f'Hola {nombre}, el próximo año tendrás {edad + 1} años.')\n```\n\n### Buenas prácticas\n- Siempre mostrar un mensaje claro en el `input()` para que el usuario sepa qué debe escribir.\n- Validar que los datos ingresados sean correctos para evitar errores, por ejemplo comprobando que la edad sea un número positivo.\n\n### Ejemplo de validación sencilla:\n```python\nwhile True:\n    edad_str = input('Introduce tu edad: ')\n    if edad_str.isdigit():\n        edad = int(edad_str)\n        break\n    else:\n        print('Por favor, introduce un número válido.')\n```\n\nCon estas funciones básicas, puedes crear programas interactivos que respondan a las necesidades del usuario."
  },
  {
    "id": 4,
    "titulo": "Comentarios-y-Buenas-Practicas",
    "contenido": "Los comentarios son una herramienta fundamental para hacer que tu código sea comprensible, tanto para ti como para otras personas que lo lean o mantengan en el futuro.\n\n### Comentarios en Python\n- Se usan con el símbolo `#` para comentar una línea o una parte de ella.\n- El intérprete ignora todo lo que esté después del `#` en esa línea.\n\n```python\n# Esto es un comentario explicativo\nx = 10  # Variable que almacena la cantidad de elementos\n```\n\n### ¿Por qué usar comentarios?\n- Explicar la intención detrás de bloques complejos.\n- Dejar notas para futuras mejoras o correcciones.\n- Documentar funciones y módulos.\n\n### Buenas prácticas para escribir código limpio y mantenible:\n- **Nombres descriptivos:** Usa nombres claros y significativos para variables, funciones y clases.\n- **Indentación y estilo:** Python usa la indentación para definir bloques. Usa 4 espacios por nivel, no tabulaciones.\n- **Evita código duplicado:** Usa funciones o clases para reutilizar código.\n- **Escribe funciones pequeñas:** Cada función debe hacer una sola cosa bien.\n- **Sigue estándares:** La guía oficial PEP8 establece normas para que el código sea consistente.\n\n### Ejemplo de función bien comentada y clara:\n```python\ndef calcular_area_rectangulo(base, altura):\n    \"\"\"Calcula el área de un rectángulo dado su base y altura.\"\"\"\n    # Multiplicamos base por altura\n    area = base * altura\n    return area\n```\n\n### Herramientas para ayudar en la calidad del código:\n- Linters para verificar el estilo.\n- Documentación automática con docstrings.\n- Revisiones de código en equipo.\n\nUn código limpio no solo funciona, sino que facilita el aprendizaje, la colaboración y el mantenimiento a largo plazo."
  },
  {
    "id": 5,
    "titulo": "Condicionales-if-else",
    "contenido": "Las estructuras condicionales permiten ejecutar diferentes bloques de código dependiendo de si se cumplen o no ciertas condiciones. Son fundamentales para tomar decisiones en nuestros programas.\n\n### Sintaxis básica:\n```python\nif condicion:\n    # código si la condición es verdadera\nelif otra_condicion:\n    # código si se cumple otra condición\nelse:\n    # código si ninguna condición es verdadera\n```\n\n### Operadores comunes en condiciones:\n- Comparación: `==`, `!=`, `<`, `>`, `<=`, `>=`\n- Lógicos: `and`, `or`, `not`\n\n### Ejemplo práctico:\n```python\nedad = int(input(\"¿Cuántos años tienes? \"))\nif edad >= 65:\n    print(\"Eres un adulto mayor\")\nelif edad >= 18:\n    print(\"Eres un adulto\")\nelif edad >= 13:\n    print(\"Eres un adolescente\")\nelse:\n    print(\"Eres un niño\")\n```\n\n### Condicionales anidadas:\nPuedes colocar un `if` dentro de otro para manejar casos más específicos.\n```python\nif temperatura > 30:\n    if humedad > 70:\n        print(\"Hace mucho calor y está húmedo\")\n    else:\n        print(\"Hace mucho calor pero no está húmedo\")\n```\n\n### Buenas prácticas:\n- Mantén el código indentado y claro.\n- No abuses de múltiples `elif` si puedes usar estructuras más limpias.\n- Usa comentarios para clarificar decisiones complejas."
  },
  {
    "id": 6,
    "titulo": "Bucles-for",
    "contenido": "El bucle `for` permite repetir un bloque de código por cada elemento de una secuencia. Es ideal para recorrer listas, cadenas, rangos y otros iterables.\n\n### Sintaxis básica:\n```python\nfor variable in iterable:\n    # código a ejecutar\n```\n\n### Iterar con range():\n```python\nfor i in range(1, 6):\n    print(f\"Iteración número {i}\")\n```\n\n### Recorrer una lista:\n```python\nnombres = [\"Ana\", \"Luis\", \"Carlos\"]\nfor nombre in nombres:\n    print(f\"Hola {nombre}\")\n```\n\n### Enumerar elementos con índice:\n```python\nfor indice, valor in enumerate(nombres):\n    print(f\"Índice {indice}: {valor}\")\n```\n\n### Anidar bucles:\n```python\nfor i in range(3):\n    for j in range(2):\n        print(f\"i={i}, j={j}\")\n```\n\n### Uso de `else` con for:\n```python\nfor numero in range(3):\n    print(numero)\nelse:\n    print(\"El bucle terminó sin interrupciones\")\n```\n\nEl `for` es esencial para recorrer estructuras y automatizar tareas repetitivas."
  },
  {
    "id": 7,
    "titulo": "Bucles-while",
    "contenido": "El bucle `while` permite repetir un bloque de código mientras se cumpla una condición. A diferencia del `for`, no se sabe cuántas veces se ejecutará.\n\n### Sintaxis básica:\n```python\nwhile condicion:\n    # código a ejecutar\n```\n\n### Ejemplo simple:\n```python\ncontador = 0\nwhile contador < 5:\n    print(\"Contador:\", contador)\n    contador += 1\n```\n\n### Validación con `while`:\n```python\nclave = \"python123\"\nintento = \"\"\nwhile intento != clave:\n    intento = input(\"Introduce la clave: \")\nprint(\"¡Acceso concedido!\")\n```\n\n### Cuidado con los bucles infinitos:\nAsegúrate de que la condición cambie dentro del bucle, o nunca terminará.\n```python\n# Ejemplo de bucle infinito (NO ejecutar)\n# while True:\n#     print(\"Esto nunca para\")\n```\n\n### Uso de `else` con while:\n```python\nnumero = 0\nwhile numero < 3:\n    print(numero)\n    numero += 1\nelse:\n    print(\"Bucle finalizado\")\n```\n\nEl `while` es muy útil para repetir tareas hasta que se cumpla una condición, como validaciones o menús interactivos."
  },
  {
    "id": 8,
    "titulo": "Control-de-flujo:-break,-continue-y-pass",
    "contenido": "Dentro de bucles, puedes modificar el flujo de ejecución usando instrucciones especiales:\n\n### `break` - Salir del bucle:\nDetiene el bucle inmediatamente, sin esperar a que se complete la iteración.\n```python\nfor i in range(10):\n    if i == 5:\n        break\n    print(i)  # Imprime de 0 a 4\n```\n\n### `continue` - Saltar a la siguiente vuelta:\nEvita el resto del código en la iteración actual y pasa a la siguiente.\n```python\nfor i in range(5):\n    if i == 2:\n        continue\n    print(i)  # Imprime 0, 1, 3, 4\n```\n\n### `pass` - No hacer nada (placeholder):\nSirve para escribir una estructura sin implementarla aún.\n```python\nfor i in range(3):\n    pass  # No hace nada\n```\n\n### En bucles `while`:\n```python\ncontador = 0\nwhile contador < 10:\n    contador += 1\n    if contador == 7:\n        continue\n    if contador == 9:\n        break\n    print(contador)\n```\n\nEstas instrucciones son clave para tener un mayor control sobre la lógica de repetición y reaccionar a ciertas condiciones durante la ejecución."
  },
  {
    "id": 9,
    "titulo": "Estructuras-anidadas",
    "contenido": "Anidar estructuras significa colocar condicionales dentro de bucles, bucles dentro de condicionales o una combinación de ambos. Esto permite construir programas más complejos y con lógica detallada.\n\n### Ejemplo: condicional dentro de un bucle\n```python\nfor numero in range(1, 11):\n    if numero % 2 == 0:\n        print(f\"{numero} es par\")\n    else:\n        print(f\"{numero} es impar\")\n```\n\n### Bucle dentro de condicional:\n```python\nrespuesta = input(\"¿Quieres ver la cuenta regresiva? (s/n): \")\nif respuesta.lower() == \"s\":\n    for i in range(5, 0, -1):\n        print(i)\n    print(\"¡Despegue!\")\n```\n\n### Bucle dentro de bucle (matrices):\n```python\nmatriz = [[1, 2], [3, 4], [5, 6]]\nfor fila in matriz:\n    for elemento in fila:\n        print(elemento, end=\" \")\n    print()\n```\n\n### Condicional dentro de `while`:\n```python\nnumero = 0\nwhile numero <= 10:\n    if numero % 3 == 0:\n        print(f\"{numero} es múltiplo de 3\")\n    numero += 1\n```\n\nLas estructuras anidadas son poderosas, pero deben usarse con cuidado para no crear código difícil de leer. Siempre usa una indentación clara y, si es posible, divide en funciones para mantener la legibilidad."
  },
  {
    "id": 10,
    "titulo": "Definición-de-funciones",
    "contenido": "### Definición de funciones en Python\n\nEn Python, una función es un bloque de código reutilizable que realiza una tarea específica. Se define usando la palabra clave `def` seguida del nombre de la función y paréntesis, que pueden incluir parámetros. Las funciones ayudan a organizar el código, hacerlo más legible y evitar repeticiones.\n\n### Sintaxis básica:\n```python\ndef nombre_funcion(param1, param2):\n    # Bloque de código\n    return resultado\n```\n\n- `def`: palabra clave para definir la función.\n- `nombre_funcion`: nombre que identifica la función (debe seguir las reglas para nombres de variables).\n- `param1, param2`: parámetros opcionales que la función puede recibir.\n- `return`: instrucción opcional para devolver un valor al llamador.\n\n### Ejemplo simple sin parámetros ni retorno:\n```python\ndef saludar():\n    print('¡Hola a todos!')\n\nsaludar()  # Llama a la función y muestra: ¡Hola a todos!\n```\n\n### Función con parámetros:\n```python\ndef saludar(nombre):\n    print(f'¡Hola, {nombre}!')\n\nsaludar('María')  # Salida: ¡Hola, María!\nsaludar('Pedro')  # Salida: ¡Hola, Pedro!\n```\n\n### Función con retorno de valor:\n```python\ndef sumar(a, b):\n    return a + b\n\nresultado = sumar(10, 5)\nprint(resultado)  # Imprime: 15\n```\n\n### Parámetros con valores por defecto:\nPuedes asignar valores por defecto a los parámetros, lo que hace que sean opcionales al llamar a la función.\n```python\ndef saludar(nombre='Amigo'):\n    print(f'¡Hola, {nombre}!')\n\nsaludar()        # Salida: ¡Hola, Amigo!\nsaludar('Laura') # Salida: ¡Hola, Laura!\n```\n\n### Parámetros arbitrarios:\nSi no sabes cuántos argumentos recibirás, puedes usar `*args` para parámetros posicionales y `**kwargs` para parámetros nombrados.\n```python\ndef mostrar_nombres(*args):\n    for nombre in args:\n        print(nombre)\n\nmostrar_nombres('Ana', 'Luis', 'Carlos')\n# Salida:\n# Ana\n# Luis\n# Carlos\n```\n\n### Documentación (docstrings):\nEs buena práctica documentar las funciones para describir qué hacen y sus parámetros.\n```python\ndef saludar(nombre):\n    \"\"\"Imprime un saludo personalizado con el nombre dado.\"\"\"\n    print(f'¡Hola, {nombre}!')\n```\n\n### Funciones anidadas:\nSe pueden definir funciones dentro de otras funciones para encapsular lógica.\n```python\ndef externa():\n    def interna():\n        print('Soy una función interna')\n    interna()\n\nexterna()  # Imprime: Soy una función interna\n```\n\n### Resumen\n- Usa `def` para definir funciones.\n- Las funciones pueden tener parámetros con o sin valores por defecto.\n- `return` permite devolver valores.\n- Documenta tus funciones con docstrings para facilitar su uso.\n\nEntender bien la definición y uso de funciones es fundamental para escribir código Python limpio, eficiente y fácil de mantener."
  },
  {
    "id": 11,
    "titulo": "Parámetros-y-Argumentos",
    "contenido": "### Parámetros y argumentos en funciones de Python\n\nLas funciones permiten que un bloque de código reciba datos externos para procesarlos, lo que se logra mediante parámetros y argumentos.\n\n---\n\n## Parámetros\n\nLos **parámetros** son variables que se definen en la cabecera de la función y representan los valores que la función espera recibir al ser llamada.\n\nEjemplo básico:\n```python\ndef saludar(nombre):  # 'nombre' es el parámetro\n    print(f'¡Hola, {nombre}!')\n```\n\n## Argumentos\n\nLos **argumentos** son los valores que se pasan a la función cuando la llamamos. Estos valores se asignan a los parámetros según la posición o el nombre.\n\nEjemplo:\n```python\nsaludar('Ana')  # 'Ana' es el argumento\n```\n\n---\n\n## Tipos de parámetros y argumentos\n\n### 1. Parámetros posicionales\n\nSe asignan en función del orden en que se pasan los argumentos.\n\n```python\ndef sumar(a, b):\n    return a + b\n\nprint(sumar(3, 5))  # 8\n```\n\n### 2. Parámetros con valores por defecto\n\nSe pueden asignar valores predeterminados a los parámetros. Si no se pasa argumento, se usa el valor por defecto.\n\n```python\ndef saludar(nombre='Amigo'):\n    print(f'¡Hola, {nombre}!')\n\nsaludar()        # ¡Hola, Amigo!\nsaludar('Luis')  # ¡Hola, Luis!\n```\n\n### 3. Argumentos nombrados (Keyword Arguments)\n\nAl llamar a la función, se puede indicar explícitamente a qué parámetro corresponde cada argumento usando `nombre_parametro=valor`.\n\nEsto permite cambiar el orden y mejorar la legibilidad.\n\n```python\nprint(sumar(b=10, a=4))  # 14\n```\n\n### 4. Parámetros arbitrarios con `*args` y `**kwargs`\n\nA veces no se sabe cuántos argumentos se van a recibir. Python permite capturar argumentos variables:\n\n- `*args` captura una tupla de argumentos posicionales.\n- `**kwargs` captura un diccionario con argumentos nombrados.\n\n#### Ejemplo `*args`:\n```python\ndef imprimir_nombres(*nombres):\n    for nombre in nombres:\n        print(nombre)\n\nimprimir_nombres('Ana', 'Luis', 'María')\n```\n\n#### Ejemplo `**kwargs`:\n```python\ndef mostrar_info(**info):\n    for clave, valor in info.items():\n        print(f'{clave}: {valor}')\n\nmostrar_info(nombre='Ana', edad=25, ciudad='Madrid')\n```\n\n---\n\n## Valores de retorno\n\nLas funciones pueden devolver valores con `return`, permitiendo que el resultado sea usado fuera de la función.\n\nSi no se usa `return`, la función devuelve `None`.\n\n```python\ndef cuadrado(x):\n    return x * x\n\nresultado = cuadrado(4)\nprint(resultado)  # 16\n```\n\n## Uso avanzado de parámetros\n\n### Orden de los parámetros\n\nCuando se combinan varios tipos, el orden correcto es:\n\n1. Parámetros posicionales obligatorios\n2. Parámetros con valores por defecto\n3. Parámetros arbitrarios `*args`\n4. Parámetros arbitrarios nombrados `**kwargs`\n\nEjemplo:\n```python\ndef funcion(a, b=2, *args, **kwargs):\n    print(f'a={a}, b={b}')\n    print(f'args={args}')\n    print(f'kwargs={kwargs}')\n\nfuncion(1, 3, 4, 5, x=10, y=20)\n```\n\n### Parámetros solo nombrados (Python 3.8+)\n\nSe pueden definir parámetros que solo se pasan nombrándolos explícitamente usando `*`:\n```python\ndef funcion(a, b, *, c, d):\n    print(a, b, c, d)\n\nfuncion(1, 2, c=3, d=4)  # Correcto\n# funcion(1, 2, 3, 4)    # Error\n```\n\n### Parámetros mutables y valores por defecto\n\nEvitar usar objetos mutables (como listas o diccionarios) como valores por defecto para parámetros, porque se comparten entre llamadas:\n\n```python\ndef agregar_elemento(elemento, lista=[]):\n    lista.append(elemento)\n    return lista\n\nprint(agregar_elemento(1))  # [1]\nprint(agregar_elemento(2))  # [1, 2]  <- Problema\n```\n\nSolución:\n```python\ndef agregar_elemento(elemento, lista=None):\n    if lista is None:\n        lista = []\n    lista.append(elemento)\n    return lista\n```\n\n---\n\n## Buenas prácticas\n\n- Usa nombres claros para parámetros.\n- Documenta qué espera cada parámetro y qué devuelve la función.\n- Usa argumentos nombrados para mejorar la claridad.\n- Evita efectos secundarios dentro de funciones; que sean predecibles.\n\n---\n\nComprender y dominar parámetros y argumentos es clave para construir funciones flexibles, reutilizables y fáciles de mantener en Python."
  },
  {
    "id": 12,
    "titulo": "Scope-de-Variables",
    "contenido": "### Scope de variables en Python: Ámbito local, global y no local\n\nEl concepto de **scope** (ámbito) se refiere a la zona del programa donde una variable es reconocida y accesible. Es fundamental entenderlo para evitar errores como variables no definidas o modificaciones inesperadas.\n\n---\n\n## 1. Ámbito Local\n\nLas variables definidas dentro de una función solo existen mientras se ejecuta la función y no son accesibles fuera de ella.\n\n```python\ndef funcion_local():\n    mensaje = 'Hola desde ámbito local'\n    print(mensaje)  # Funciona dentro\n\nfuncion_local()\n#print(mensaje)  # Error: mensaje no está definida fuera\n```\n\nCada llamada a la función crea un nuevo espacio de memoria para las variables locales.\n\n---\n\n## 2. Ámbito Global\n\nUna variable definida fuera de funciones o clases se considera global y puede ser usada en cualquier parte del módulo.\n\n```python\ncontador = 0  # Variable global\n\ndef mostrar_contador():\n    print(contador)  # Accede a variable global\n\nmostrar_contador()  # Imprime: 0\nprint(contador)     # También imprime: 0\n```\n\n### Modificar variables globales dentro de funciones\n\nPara modificar una variable global dentro de una función se debe usar la palabra clave `global`:\n\n```python\ncontador = 0\n\ndef incrementar():\n    global contador\n    contador += 1\n\nincrementar()\nprint(contador)  # Imprime: 1\n```\n\nSi no declaras `global`, Python crea una nueva variable local con el mismo nombre:\n\n```python\nx = 5\n\ndef modificar():\n    x = 10  # Variable local, no modifica global\n    print(f'Dentro: {x}')\n\nmodificar()      # Imprime: Dentro: 10\nprint(x)        # Imprime: 5 (global sin cambios)\n```\n\n---\n\n## 3. Ámbito Enclosing o No Local\n\nCuando tienes funciones dentro de funciones (funciones anidadas), la función interna puede acceder a variables definidas en la función externa.\n\nPara modificar estas variables externas dentro de la función interna se usa `nonlocal`.\n\n```python\ndef externa():\n    contador = 0\n\n    def interna():\n        nonlocal contador\n        contador += 1\n        print(contador)\n\n    interna()\n    interna()\n\nexterna()  # Imprime: 1, luego 2\n```\n\nSin `nonlocal`, la función interna crearía una variable local nueva y no modificaría la externa.\n\n---\n\n## 4. Ámbito Built-in\n\nPython tiene un conjunto de nombres predefinidos (funciones, excepciones, constantes) accesibles desde cualquier parte. Este es el último lugar donde Python busca variables.\n\nEjemplo de función built-in:\n```python\nprint(len('Python'))  # len es función built-in\n```\n\n---\n\n## 5. Orden de búsqueda LEGB\n\nCuando accedes a una variable, Python sigue esta búsqueda en orden:\n\n- **L**ocal — dentro de la función o bloque actual.\n- **E**nclosing — en funciones externas que contienen la función actual.\n- **G**lobal — en el módulo actual.\n- **B**uilt-in — nombres predefinidos de Python.\n\nEjemplo que muestra LEGB:\n```python\nx = 'global'\n\ndef fuera():\n    x = 'local en fuera'\n    def dentro():\n        print(x)  # Busca en enclosing, encuentra 'local en fuera'\n    dentro()\n\nfuera()  # Imprime: local en fuera\n```\n\n---\n\n## 6. Variables locales vs globales con ejemplos prácticos\n\n### Ejemplo 1: Variables locales independientes\n```python\ndef f():\n    a = 5\n    print(f'Local a = {a}')\n\nf()  # Local a = 5\n#print(a)  # Error, no existe fuera\n```\n\n### Ejemplo 2: Modificar variable global sin `global`\n```python\ncontador = 10\n\ndef incrementar():\n    contador = contador + 1  # Error: contador local usado antes de asignar\n```\n\nEste error ocurre porque Python interpreta que `contador` dentro de la función es local, pero intentas usarlo antes de asignar.\n\nSolución:\n```python\ndef incrementar():\n    global contador\n    contador += 1\n```\n\n---\n\n## 7. Buenas prácticas y recomendaciones\n\n- Minimiza el uso de variables globales para evitar efectos secundarios difíciles de rastrear.\n- Prefiere pasar variables como parámetros y devolver resultados.\n- Usa nombres claros para variables locales y globales para evitar confusión.\n- Usa `global` y `nonlocal` solo cuando sea estrictamente necesario.\n- Documenta el comportamiento esperado respecto al scope en funciones complejas.\n\n---\n\n## 8. Casos especiales\n\n### Variables mutables en scope global\n\nSi una variable global es mutable (como una lista o diccionario), se puede modificar su contenido sin usar `global`:\n\n```python\nlista = []\n\ndef agregar(elemento):\n    lista.append(elemento)  # Modifica contenido sin declarar global\n\nagregar(1)\nagregar(2)\nprint(lista)  # [1, 2]\n```\n\n### Redefinir variables globales dentro de funciones\n\nSi reasignas una variable global dentro de una función sin `global`, Python crea una local nueva con el mismo nombre, dejando la global intacta.\n\n### Scope y clases\n\nLas variables dentro de métodos de clase tienen scope local al método, pero pueden acceder a atributos de instancia o clase usando `self` o el nombre de la clase.\n\n---\n\nEntender el scope de variables en Python es fundamental para escribir código claro, evitar bugs relacionados con variables no definidas o valores inesperados, y gestionar correctamente la memoria y el estado del programa."
  },
  {
    "id": 13,
    "titulo": "Funciones-lambda",
    "contenido": "### Funciones lambda: funciones anónimas y su uso en Python\n\nLas funciones **lambda** son funciones anónimas, pequeñas y rápidas, que se definen con la palabra clave `lambda` y consisten en una única expresión. Son ideales para operaciones simples donde no se requiere una función con nombre explícito.\n\n---\n\n### Sintaxis\n```python\nlambda argumentos: expresión\n```\n\n- **argumentos**: parámetros que la función recibe.\n- **expresión**: operación que se evalúa y devuelve como resultado.\n\nEjemplo básico:\n```python\n# Sumar 5 a un número\nsumar_cinco = lambda x: x + 5\nprint(sumar_cinco(10))  # 15\n```\n\n---\n\n### Comparación con funciones normales\n\n```python\n# Función tradicional\n def multiplicar_por_dos(x):\n     return x * 2\n\n# Función lambda equivalente\nmultiplicar_lambda = lambda x: x * 2\n```\n\nAmbas hacen lo mismo, pero la lambda es más compacta.\n\n---\n\n### Usos comunes\n\n#### 1. Funciones de orden superior\n\nPython tiene funciones que aceptan otras funciones como argumentos. Las lambdas son ideales para usarse en estos casos:\n\n- **map()**: Aplica una función a cada elemento de una colección.\n\n```python\nnumeros = [1, 2, 3, 4]\ncuadrados = list(map(lambda x: x**2, numeros))\nprint(cuadrados)  # [1, 4, 9, 16]\n```\n\n- **filter()**: Filtra elementos de una colección según una condición.\n\n```python\npares = list(filter(lambda x: x % 2 == 0, numeros))\nprint(pares)  # [2, 4]\n```\n\n- **sorted()**: Ordena colecciones con claves personalizadas.\n\n```python\npersonas = [('Ana', 25), ('Luis', 30), ('Maria', 20)]\nordenado = sorted(personas, key=lambda p: p[1])\nprint(ordenado)  # [('Maria', 20), ('Ana', 25), ('Luis', 30)]\n```\n\n#### 2. Uso en funciones internas\n\nSe usan para definir rápidamente pequeñas funciones que se pasan como argumentos o se usan temporalmente.\n\n---\n\n### Ventajas\n\n- Sintaxis compacta y rápida.\n- No es necesario definir una función completa.\n- Fácil integración con funciones que requieren funciones como argumento.\n\n---\n\n### Limitaciones\n\n- Solo una expresión, no permite múltiples sentencias.\n- Pueden hacer el código difícil de leer si se usan en exceso o con lógica compleja.\n- Sin nombre propio, dificultan la depuración.\n\n---\n\n### Ejemplos avanzados\n\n```python\n# Lambda con múltiples argumentos\nmaximo = lambda a, b: a if a > b else b\nprint(maximo(8, 5))  # 8\n\n# Lambdas que devuelven funciones\ndef crear_potencia(n):\n    return lambda x: x ** n\n\ncuadrado = crear_potencia(2)\ncubo = crear_potencia(3)\nprint(cuadrado(4))  # 16\nprint(cubo(2))      # 8\n\n# Uso en listas y comprehensions\npares = list(filter(lambda x: x % 2 == 0, range(20)))\nprint(pares)  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n```\n\n---\n\n### Buenas prácticas\n\n- Usa lambdas para funciones simples y de corta duración.\n- Para lógica compleja o reutilizable, utiliza funciones con `def`.\n- No abuses de lambdas para mantener la claridad y facilidad de mantenimiento.\n\n---\n\n### Contextos donde se usan funciones lambda\n\n- Procesamiento de datos en pandas, NumPy, y otros frameworks.\n- Funciones rápidas en interfaces gráficas (eventos, callbacks).\n- Expresiones funcionales en programación funcional con Python.\n\n---\n\nEn resumen, las funciones lambda son una herramienta fundamental en Python para escribir código compacto y funcional en tareas que requieren pequeñas funciones sin la necesidad de definirlas con nombre, facilitando la programación funcional y la manipulación rápida de datos."
  },
  {
    "id": 14,
    "titulo": "Modulos-y-Paquetes",
    "contenido": "### Módulos y paquetes: organización del código en Python\n\nPython permite estructurar el código en **módulos** y **paquetes**, facilitando la reutilización, la mantenibilidad y la escalabilidad de proyectos.\n\n---\n\n### ¿Qué es un módulo?\n\nUn módulo es un archivo con extensión `.py` que puede contener funciones, clases, variables y código ejecutable. Es la unidad básica de organización en Python.\n\nPor ejemplo, un archivo `matematicas.py` puede contener:\n\n```python\ndef sumar(a, b):\n    return a + b\n\ndef restar(a, b):\n    return a - b\n\nPI = 3.14159\n```\n\nPuedes importar este módulo en otro script para usar sus funciones y constantes:\n\n```python\nimport matematicas\n\nprint(matematicas.sumar(5, 3))  # 8\nprint(matematicas.PI)           # 3.14159\n```\n\n---\n\n### Formas de importar módulos\n\n- **Importar todo el módulo:**\n  ```python\n  import matematicas\n  matematicas.sumar(1, 2)\n  ```\n\n- **Importar solo ciertas funciones o variables:**\n  ```python\n  from matematicas import sumar, PI\n  print(sumar(2, 3))\n  print(PI)\n  ```\n\n- **Importar con alias para abreviar nombres:**\n  ```python\n  import matematicas as mt\n  print(mt.restar(10, 4))\n  ```\n\n---\n\n### ¿Qué es un paquete?\n\nUn paquete es una carpeta que contiene uno o más módulos y un archivo especial llamado `__init__.py`, que indica a Python que la carpeta debe tratarse como un paquete.\n\nEjemplo de estructura de paquete:\n\n```\nmi_paquete/\n├── __init__.py\n├── archivo1.py\n├── archivo2.py\n└── subpaquete/\n    ├── __init__.py\n    └── archivo3.py\n```\n\n- El archivo `__init__.py` puede estar vacío o contener código para inicializar el paquete.\n\n---\n\n### Importar desde paquetes y subpaquetes\n\n- Importar un módulo completo:\n\n```python\nfrom mi_paquete import archivo1\narchivo1.funcion()\n```\n\n- Importar una función específica:\n\n```python\nfrom mi_paquete.archivo2 import funcion_especial\nfuncion_especial()\n```\n\n- Importar desde un subpaquete:\n\n```python\nfrom mi_paquete.subpaquete import archivo3\narchivo3.otra_funcion()\n```\n\n---\n\n### Ventajas de módulos y paquetes\n\n- **Reutilización:** Permiten compartir código común entre diferentes programas.\n- **Modularidad:** Facilitan dividir programas grandes en partes más pequeñas y manejables.\n- **Namespaces:** Ayudan a evitar conflictos de nombres entre variables y funciones.\n- **Mantenibilidad:** Es más sencillo actualizar y corregir errores en módulos específicos sin afectar todo el programa.\n\n---\n\n### Módulos estándar de Python\n\nPython incluye una amplia biblioteca estándar con módulos preinstalados:\n\n- `math`: funciones matemáticas avanzadas.\n- `random`: generación de números aleatorios.\n- `datetime`: manejo de fechas y tiempos.\n- `os`: interacción con el sistema operativo.\n- `sys`: acceso a variables y funciones del intérprete.\n\nEjemplo:\n\n```python\nimport math\nprint(math.factorial(5))  # 120\n```\n\n---\n\n### Creación de módulos reutilizables\n\n- Mantén cada módulo enfocado en una responsabilidad o funcionalidad.\n- Usa nombres descriptivos para facilitar su identificación.\n- Documenta cada módulo con docstrings para explicar su propósito.\n\n---\n\n### Uso de paquetes externos\n\n- Python permite instalar paquetes de terceros usando `pip`, el gestor de paquetes.\n- Estos paquetes amplían las funcionalidades disponibles (por ejemplo, `requests` para hacer peticiones HTTP).\n\n```bash\npip install requests\n```\n\n```python\nimport requests\nrespuesta = requests.get('https://api.example.com')\nprint(respuesta.status_code)\n```\n\n---\n\n### `__init__.py` y su función\n\n- Hace que Python trate la carpeta como un paquete.\n- Puede ejecutar código de inicialización o importar submódulos para exponerlos directamente.\n\nPor ejemplo, en `mi_paquete/__init__.py`:\n\n```python\nfrom .archivo1 import funcion\nfrom .subpaquete.archivo3 import otra_funcion\n```\n\nAsí, puedes importar funciones directamente:\n\n```python\nfrom mi_paquete import funcion, otra_funcion\n```\n\n---\n\n### Buenas prácticas\n\n- Organiza el código según su funcionalidad y cohesión.\n- Mantén los módulos y paquetes bien documentados.\n- Evita ciclos de importación entre módulos.\n- Usa alias para mejorar la legibilidad cuando importes módulos con nombres largos.\n- Separa código ejecutable y definiciones; usa bloques `if __name__ == '__main__':` para código que solo se debe ejecutar cuando el módulo se corre directamente.\n\n---\n\nOrganizar el código en módulos y paquetes es clave para desarrollar proyectos Python limpios, escalables y mantenibles, permitiendo aprovechar toda la potencia y flexibilidad del lenguaje."
  },
  {
    "id": 15,
    "titulo": "Librerias-estandar",
    "contenido": "### Librerías estándar en Python: Uso avanzado de math, random y datetime\n\nPython incluye una biblioteca estándar muy rica que ofrece módulos para resolver una gran variedad de problemas comunes sin necesidad de instalar nada adicional. Entre estos, `math`, `random` y `datetime` son esenciales para cálculo, generación de números aleatorios y manejo de fechas.\n\n---\n\n## Módulo math: Funciones matemáticas avanzadas\n\nEste módulo provee acceso a funciones matemáticas como trigonometría, logaritmos, exponenciales, y constantes matemáticas.\n\n#### Funciones importantes:\n\n- `math.ceil(x)`: redondea hacia arriba al entero más cercano.\n- `math.floor(x)`: redondea hacia abajo.\n- `math.exp(x)`: exponencial de x, e**x.\n- `math.log(x[, base])`: logaritmo en base especificada (por defecto natural).\n- `math.degrees(x)`, `math.radians(x)`: convertir entre radianes y grados.\n\n#### Constantes:\n\n- `math.pi`: 3.141592653589793\n- `math.e`: 2.718281828459045\n\n#### Ejemplos:\n\n```python\nimport math\n\nprint(math.ceil(4.2))       # 5\nprint(math.floor(4.8))      # 4\nprint(math.exp(1))          # 2.718281828459045\nprint(math.log(100, 10))    # 2.0\nprint(math.degrees(math.pi/2))  # 90.0\n```\n\n---\n\n## Módulo random: Generación y manejo de aleatoriedad\n\nIdeal para simulaciones, juegos, muestreos y pruebas.\n\n#### Funciones adicionales:\n\n- `random.uniform(a, b)`: número flotante aleatorio en [a, b].\n- `random.sample(population, k)`: devuelve una lista con k elementos únicos de la población.\n- `random.gauss(mu, sigma)`: valor aleatorio con distribución normal.\n- `random.seed(x)`: fija la semilla para reproducibilidad.\n\n#### Ejemplo:\n\n```python\nimport random\n\nrandom.seed(42)  # Semilla fija para resultados reproducibles\n\nprint(random.uniform(1.5, 5.5))\nprint(random.sample([1, 2, 3, 4, 5], 3))\nprint(random.gauss(0, 1))  # Media 0, desviación estándar 1\n```\n\n---\n\n## Módulo datetime: Manipulación de fechas y tiempos\n\nClave para registros, programaciones, y cálculos temporales.\n\n#### Clases clave:\n\n- `datetime.date`: representa solo fechas.\n- `datetime.time`: representa solo tiempos.\n- `datetime.datetime`: combinación fecha y hora.\n- `datetime.timedelta`: diferencia entre fechas/tiempos.\n\n#### Funciones y métodos útiles:\n\n- `datetime.strptime(string, formato)`: convierte string en datetime según formato.\n- `datetime.strftime(formato)`: convierte datetime a string según formato.\n- Atributos: `.year`, `.month`, `.day`, `.hour`, `.minute`, `.second`.\n\n#### Ejemplo avanzado:\n\n```python\nfrom datetime import datetime, timedelta\n\nfecha_str = '2025-06-11 15:30:00'\nfecha_obj = datetime.strptime(fecha_str, '%Y-%m-%d %H:%M:%S')\nprint(fecha_obj)\n\n# Añadir 3 horas y 45 minutos\nnueva_fecha = fecha_obj + timedelta(hours=3, minutes=45)\nprint(nueva_fecha)\n\n# Formatear fecha para mostrar\nprint(nueva_fecha.strftime('%d/%m/%Y %I:%M %p'))  # 11/06/2025 07:15 PM\n```\n\n---\n\n## Aplicaciones prácticas\n\n- **math:** cálculos científicos, ingeniería, estadísticas.\n- **random:** juegos, pruebas automatizadas, simulaciones de Monte Carlo.\n- **datetime:** programación de eventos, registros, cálculos de duración.\n\n---\n\n## Buenas prácticas\n\n- Importar solo lo necesario con `from module import function` para mejorar legibilidad.\n- Usar `random.seed()` en tests para resultados repetibles.\n- Documentar formatos de fecha/hora usados para evitar confusiones.\n- Aprovechar excepciones y validaciones para evitar errores en fechas y números.\n\n---\n\nDominar estas librerías estándar hace que tu código Python sea más eficiente, claro y potente, permitiéndote afrontar muchos desafíos comunes con facilidad."
  },
  {
    "id": 16,
    "titulo": "Clases-y-objetos",
    "contenido": "### Clases y objetos: fundamentos y conceptos avanzados de la Programación Orientada a Objetos (POO) en Python\n\nLa Programación Orientada a Objetos (POO) es un paradigma que permite organizar y estructurar el código usando **clases** y **objetos** para representar entidades del mundo real o conceptos abstractos.\n\n---\n\n## 1. ¿Qué es una clase?\n\nUna clase es un molde o plantilla que define atributos (propiedades) y métodos (funciones) comunes para los objetos que se creen a partir de ella.\n\n```python\nclass Persona:\n    def __init__(self, nombre, edad):\n        self.nombre = nombre  # atributo\n        self.edad = edad      # atributo\n\n    def saludar(self):\n        print(f\"Hola, me llamo {self.nombre} y tengo {self.edad} años.\")\n```\n\n- `__init__` es el método constructor que inicializa cada objeto con valores específicos.\n\n---\n\n## 2. Creación de objetos\n\nUn objeto es una instancia de una clase, con sus propios valores para los atributos.\n\n```python\npersona1 = Persona('Luis', 30)\npersona1.saludar()  # Hola, me llamo Luis y tengo 30 años.\n```\n\n---\n\n## 3. Atributos y métodos\n\n- **Atributos:** variables que describen características del objeto.\n- **Métodos:** funciones que definen comportamientos del objeto.\n\nSe accede a ellos usando la sintaxis `objeto.atributo` o `objeto.metodo()`.\n\n---\n\n## 4. Encapsulamiento\n\nOcultar detalles internos para proteger los datos del objeto.\n\n- Prefijo `_` indica atributo o método \"protegido\" (convención para no usar directamente).\n- Prefijo `__` genera nombre interno para evitar accesos externos directos (name mangling).\n\n```python\nclass Cuenta:\n    def __init__(self, titular, saldo=0):\n        self.titular = titular\n        self.__saldo = saldo  # atributo privado\n\n    def depositar(self, monto):\n        if monto > 0:\n            self.__saldo += monto\n\n    def mostrar_saldo(self):\n        print(f\"Saldo: {self.__saldo}\")\n```\n\n---\n\n## 5. Herencia\n\nPermite crear nuevas clases basadas en otras, heredando sus atributos y métodos, y agregando o modificando funcionalidades.\n\n```python\nclass Empleado(Persona):\n    def __init__(self, nombre, edad, salario):\n        super().__init__(nombre, edad)  # llama al constructor de la clase base\n        self.salario = salario\n\n    def mostrar_salario(self):\n        print(f\"Salario: ${self.salario}\")\n```\n\n---\n\n## 6. Polimorfismo\n\nLa capacidad de usar métodos con el mismo nombre en distintas clases, con comportamientos específicos.\n\n```python\nclass Animal:\n    def hablar(self):\n        pass\n\nclass Perro(Animal):\n    def hablar(self):\n        return \"Guau\"\n\nclass Gato(Animal):\n    def hablar(self):\n        return \"Miau\"\n\nanimales = [Perro(), Gato()]\nfor animal in animales:\n    print(animal.hablar())  # Guau\n                          # Miau\n```\n\n---\n\n## 7. Métodos especiales (Dunder Methods)\n\nPython tiene métodos con nombres especiales para personalizar comportamiento, como:\n\n- `__str__`: define la representación en string del objeto.\n- `__repr__`: representación oficial para debugging.\n- `__eq__`: define cómo comparar dos objetos con `==`.\n\n```python\nclass Punto:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"Punto({self.x}, {self.y})\"\n\n    def __eq__(self, otro):\n        return self.x == otro.x and self.y == otro.y\n```\n\n---\n\n## 8. Propiedades (Property)\n\nPermiten controlar el acceso a atributos con métodos getter/setter sin cambiar la sintaxis.\n\n```python\nclass Circulo:\n    def __init__(self, radio):\n        self._radio = radio\n\n    @property\n    def radio(self):\n        return self._radio\n\n    @radio.setter\n    def radio(self, valor):\n        if valor > 0:\n            self._radio = valor\n        else:\n            print(\"El radio debe ser positivo\")\n```\n\n---\n\n## 9. Composición\n\nUna clase puede contener objetos de otras clases, para modelar relaciones \"tiene un\".\n\n```python\nclass Motor:\n    def __init__(self, tipo):\n        self.tipo = tipo\n\nclass Coche:\n    def __init__(self, marca, motor):\n        self.marca = marca\n        self.motor = motor\n\nmotor_v6 = Motor('V6')\ncoche = Coche('Toyota', motor_v6)\nprint(coche.motor.tipo)  # V6\n```\n\n---\n\n## 10. Ventajas de la POO\n\n- Código modular y reutilizable.\n- Fácil mantenimiento y extensión.\n- Modela problemas reales de forma intuitiva.\n\n---\n\nDominar estos conceptos te permitirá crear programas robustos, escalables y fáciles de entender en Python, aprovechando todo el potencial de la Programación Orientada a Objetos."
  },
  {
    "id": 17,
    "titulo": "Atributos-y-metodos",
    "contenido": "### Atributos y métodos: propiedades y comportamientos en clases de Python, explicados a fondo\n\nLos atributos y métodos son los bloques básicos de construcción en una clase. Permiten almacenar datos y definir acciones que los objetos pueden realizar.\n\n---\n\n## 1. Atributos\n\n### Tipos de atributos\n\n- **Atributos de instancia:** Son específicos para cada objeto y se definen normalmente dentro del método `__init__` usando `self`.\n- **Atributos de clase:** Son compartidos por todas las instancias de la clase y se definen fuera de cualquier método.\n\nEjemplo de atributo de clase:\n```python\nclass Persona:\n    especie = 'Humano'  # atributo de clase\n\n    def __init__(self, nombre):\n        self.nombre = nombre  # atributo de instancia\n```\n\n### Modificación y acceso\n\nSe accede y modifica usando `objeto.atributo`.\n\n```python\np = Persona('Ana')\nprint(p.nombre)  # Ana\nprint(Persona.especie)  # Humano\np.nombre = 'Luis'\n```\n\n---\n\n## 2. Métodos\n\n### Métodos de instancia\n\nLos más comunes, reciben `self` para acceder a atributos y otros métodos.\n\n```python\nclass Coche:\n    def arrancar(self):\n        print(\"El coche está arrancando\")\n```\n\n### Métodos de clase\n\nUsan el decorador `@classmethod` y reciben `cls` como primer argumento para acceder a atributos o métodos de clase.\n\n```python\nclass Contador:\n    cuenta = 0\n\n    @classmethod\n    def incrementar(cls):\n        cls.cuenta += 1\n```\n\n### Métodos estáticos\n\nUsan el decorador `@staticmethod` y no reciben `self` ni `cls`. Son funciones relacionadas con la clase pero que no necesitan acceder a atributos o métodos.\n\n```python\nclass Utilidades:\n    @staticmethod\n    def es_par(num):\n        return num % 2 == 0\n```\n\n---\n\n## 3. Encapsulamiento\n\n### Atributos privados y protegidos\n\n- Por convención, atributos con un guion bajo `_` son \"protegidos\" (no se deben usar fuera de la clase).\n- Con doble guion bajo `__` se activan mecanismos internos para dificultar su acceso externo.\n\nEjemplo:\n```python\nclass Banco:\n    def __init__(self, saldo):\n        self.__saldo = saldo  # privado\n\n    def mostrar_saldo(self):\n        print(f\"Saldo: {self.__saldo}\")\n```\n\n### Getters y setters\n\nSe usan para acceder y modificar atributos privados de forma controlada.\n\n```python\nclass Producto:\n    def __init__(self, precio):\n        self.__precio = precio\n\n    def get_precio(self):\n        return self.__precio\n\n    def set_precio(self, valor):\n        if valor > 0:\n            self.__precio = valor\n```\n\nTambién se pueden implementar con `@property` y `@atributo.setter` para facilitar la sintaxis.\n\n---\n\n## 4. Métodos especiales\n\n### `__str__` y `__repr__`\n\nDefinen la representación en texto del objeto para impresión y debugging.\n\n```python\nclass Punto:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"Punto({self.x}, {self.y})\"\n```\n\n### `__eq__`, `__lt__` y otros operadores\n\nPermiten definir cómo se comparan objetos con operadores estándar.\n\n---\n\n## 5. Ejemplo completo\n\n```python\nclass Persona:\n    especie = 'Humano'\n\n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.__edad = edad  # privado\n\n    def saludar(self):\n        print(f\"Hola, soy {self.nombre}\")\n\n    @property\n    def edad(self):\n        return self.__edad\n\n    @edad.setter\n    def edad(self, valor):\n        if valor >= 0:\n            self.__edad = valor\n\n    @classmethod\n    def especie_info(cls):\n        print(f\"Todos somos {cls.especie}\")\n\np = Persona('Luis', 40)\np.saludar()\nprint(p.edad)\np.edad = 45\nPersona.especie_info()\n```\n\n---\n\nDominar atributos y métodos permite crear objetos bien definidos, encapsulados y con comportamientos claros, facilitando la escalabilidad y mantenibilidad del código."
  },
  {
    "id": 18,
    "titulo": "Constructor-__init__",
    "contenido": "### Constructor __init__: inicialización avanzada de objetos en Python\n\nEl método `__init__` es el constructor de las clases en Python, y su correcto uso es clave para crear objetos robustos y flexibles.\n\n---\n\n## 1. ¿Qué es y cómo funciona?\n\n- Se ejecuta automáticamente cuando se crea un objeto.\n- Su función principal es inicializar los atributos del objeto.\n- Recibe siempre al menos un parámetro, `self`, que apunta a la instancia que se está creando.\n\nEjemplo básico:\n```python\nclass Persona:\n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n```\n\nAl crear un objeto:\n```python\np = Persona('Carlos', 30)\nprint(p.nombre)  # Carlos\n```\n\n---\n\n## 2. Parámetros con valores por defecto\n\nPuedes definir valores por defecto para los parámetros, permitiendo crear objetos con menos argumentos.\n\n```python\nclass Libro:\n    def __init__(self, titulo, autor, paginas=100):\n        self.titulo = titulo\n        self.autor = autor\n        self.paginas = paginas\n\nlibro1 = Libro('1984', 'Orwell')\nlibro2 = Libro('El Quijote', 'Cervantes', 500)\n```\n\n---\n\n## 3. Uso de `*args` y `**kwargs` en el constructor\n\nPara mayor flexibilidad, el constructor puede aceptar un número variable de argumentos:\n\n```python\nclass Ejemplo:\n    def __init__(self, *args, **kwargs):\n        print(f\"args: {args}\")\n        print(f\"kwargs: {kwargs}\")\n\nobj = Ejemplo(1, 2, 3, nombre='Ana', edad=25)\n```\n\nEsto permite pasar parámetros sin definir explícitamente cada uno.\n\n---\n\n## 4. Inicialización condicional y validación\n\nPuedes validar o transformar los valores recibidos antes de asignarlos:\n\n```python\nclass CuentaBancaria:\n    def __init__(self, titular, saldo=0):\n        self.titular = titular\n        if saldo < 0:\n            print(\"Saldo inválido, se asigna 0\")\n            self.saldo = 0\n        else:\n            self.saldo = saldo\n```\n\n---\n\n## 5. Llamadas a constructores de superclases\n\nEn herencia, puedes llamar al constructor de la clase padre con `super()` para inicializar atributos heredados.\n\n```python\nclass Animal:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\nclass Perro(Animal):\n    def __init__(self, nombre, raza):\n        super().__init__(nombre)\n        self.raza = raza\n```\n\n---\n\n## 6. Buenas prácticas en el uso de __init__\n\n- Define solo los atributos necesarios para que el objeto esté en un estado válido.\n- Usa valores por defecto para facilitar la creación de objetos.\n- Valida y sanitiza los datos dentro del constructor.\n- Mantén el constructor simple; delega funcionalidades complejas a otros métodos.\n\n---\n\n## 7. Ejemplo completo\n\n```python\nclass Vehiculo:\n    def __init__(self, tipo, color='blanco', velocidad_max=120):\n        self.tipo = tipo\n        self.color = color\n        self.velocidad_max = velocidad_max\n\n    def mostrar_info(self):\n        print(f\"Tipo: {self.tipo}, Color: {self.color}, Velocidad máxima: {self.velocidad_max} km/h\")\n\ncoche = Vehiculo('Coche', velocidad_max=180)\ncoche.mostrar_info()\n```\n\n---\n\nDominar el constructor `__init__` te permite crear objetos personalizados, consistentes y preparados para funcionar correctamente desde su creación."
  },
  {
    "id": 19,
    "titulo": "Herencia-Creacion-de-clases-derivadas",
    "contenido": "### Herencia: Creación avanzada de clases derivadas en Python\n\nLa herencia es una característica clave de la programación orientada a objetos (POO) que permite crear nuevas clases basadas en otras ya existentes, facilitando la reutilización y extensión del código.\n\n---\n\n## 1. Conceptos fundamentales de la herencia\n\n- **Clase base (superclase):** Clase original de la que se heredan atributos y métodos.\n- **Clase derivada (subclase):** Clase que hereda y puede modificar o extender la funcionalidad.\n\nEjemplo básico:\n```python\nclass Animal:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def hablar(self):\n        print(f\"{self.nombre} hace un sonido\")\n\nclass Perro(Animal):\n    def hablar(self):\n        print(f\"{self.nombre} dice guau\")\n```\n\n---\n\n## 2. Sobrescritura (Override) y extensión de métodos\n\nLa subclase puede sobrescribir métodos de la superclase para cambiar su comportamiento, o extenderlo llamando al método original con `super()`.\n\n```python\nclass Gato(Animal):\n    def hablar(self):\n        super().hablar()  # llamada al método de la superclase\n        print(f\"{self.nombre} dice miau\")\n```\n\n---\n\n## 3. Constructor en clases derivadas\n\nEs común que la subclase defina su propio constructor, pero llame al constructor de la superclase para inicializar atributos heredados.\n\n```python\nclass Ave(Animal):\n    def __init__(self, nombre, puede_volar):\n        super().__init__(nombre)\n        self.puede_volar = puede_volar\n```\n\n---\n\n## 4. Herencia múltiple\n\nPython permite heredar de varias clases al mismo tiempo. Esto aporta gran flexibilidad, aunque también puede complicar la jerarquía y el orden de resolución de métodos (MRO).\n\n```python\nclass Nadador:\n    def nadar(self):\n        print(\"Estoy nadando\")\n\nclass Pato(Animal, Nadador):\n    def hablar(self):\n        print(f\"{self.nombre} dice cuac\")\n```\n\n---\n\n## 5. Método `super()` y su importancia\n\n- `super()` facilita el acceso a métodos y atributos de la clase base, especialmente útil en herencias múltiples y cuando se sobrescriben métodos.\n- Ayuda a mantener el código limpio y evita duplicación.\n\n---\n\n## 6. Polimorfismo\n\nGracias a la herencia, diferentes clases pueden implementar el mismo método con comportamientos distintos. Esto permite usar objetos de distintas clases de manera intercambiable.\n\n```python\ndef hacer_hablar(animal):\n    animal.hablar()\n\nperro = Perro('Rex')\ngato = Gato('Mishi')\n\nhacer_hablar(perro)  # Rex dice guau\nhacer_hablar(gato)   # Mishi dice miau\n```\n\n---\n\n## 7. Clases abstractas y herencia (concepto avanzado)\n\nPython incluye el módulo `abc` para definir clases abstractas que no se instancian directamente y que obligan a las subclases a implementar ciertos métodos.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass AnimalAbstracto(ABC):\n    @abstractmethod\n    def hablar(self):\n        pass\n\nclass Perro(AnimalAbstracto):\n    def hablar(self):\n        print(\"Guau\")\n```\n\n---\n\n## 8. Buenas prácticas\n\n- Usa la herencia cuando exista una relación clara \"es un\" entre la clase base y derivada.\n- Evita herencia excesiva que complique el diseño.\n- Prefiere la composición cuando sea más apropiado.\n- Usa `super()` siempre que sobrescribas métodos para asegurar la correcta inicialización.\n\n---\n\n## 9. Ejemplo avanzado\n\n```python\nclass Vehiculo:\n    def __init__(self, marca, modelo):\n        self.marca = marca\n        self.modelo = modelo\n\n    def descripcion(self):\n        return f\"{self.marca} {self.modelo}\"\n\nclass Coche(Vehiculo):\n    def __init__(self, marca, modelo, puertas):\n        super().__init__(marca, modelo)\n        self.puertas = puertas\n\n    def descripcion(self):\n        return f\"{super().descripcion()}, {self.puertas} puertas\"\n\nmi_coche = Coche('Honda', 'Civic', 4)\nprint(mi_coche.descripcion())  # Honda Civic, 4 puertas\n```\n\n---\n\nLa herencia es una herramienta potente que, usada con criterio, mejora la reutilización del código, la mantenibilidad y la escalabilidad de los programas en Python."
  },
  {
    "id": 20,
    "titulo": "Polimorfismo-Uso-de-metodos-con-el-mismo-nombre-en-diferentes-clases",
    "contenido": "### Polimorfismo en Python: Uso avanzado de métodos con el mismo nombre en diferentes clases\n\nEl polimorfismo es una de las características más poderosas y flexibles de la programación orientada a objetos. Consiste en la capacidad de distintas clases para implementar métodos con el mismo nombre pero comportamientos específicos según su propia lógica.\n\n---\n\n## 1. Polimorfismo y diseño orientado a interfaces\n\nEl polimorfismo permite programar contra interfaces o métodos esperados, no contra implementaciones concretas. Esto favorece:\n\n- **Extensibilidad:** Se pueden agregar nuevas clases sin cambiar el código que usa esos objetos.\n- **Flexibilidad:** El mismo código puede trabajar con diferentes tipos de objetos.\n\n---\n\n## 2. Implementación implícita en Python\n\nPython no requiere declarar interfaces explícitas para usar polimorfismo. Mientras un objeto tenga el método esperado, se comportará correctamente.\n\n```python\nclass Pajaro:\n    def volar(self):\n        print(\"Pájaro volando\")\n\nclass Avion:\n    def volar(self):\n        print(\"Avión volando\")\n\ndef haz_volar(objeto_volador):\n    objeto_volador.volar()\n\nhaz_volar(Pajaro())\nhaz_volar(Avion())\n```\n\n---\n\n## 3. Polimorfismo con funciones y métodos\n\nEl polimorfismo no se limita a métodos dentro de clases, también puede darse con funciones que aceptan distintos tipos de objetos.\n\n```python\ndef area(figura):\n    return figura.area()\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n    def area(self):\n        import math\n        return math.pi * self.radio ** 2\n\nclass Cuadrado:\n    def __init__(self, lado):\n        self.lado = lado\n    def area(self):\n        return self.lado ** 2\n\nprint(area(Circulo(3)))\nprint(area(Cuadrado(4)))\n```\n\n---\n\n## 4. Polimorfismo y herencia múltiple\n\nCuando una clase hereda de múltiples clases, puede sobrescribir métodos y también aprovechar polimorfismo para manejar objetos con comportamientos diversos.\n\n```python\nclass Volador:\n    def volar(self):\n        print(\"Volando\")\n\nclass Nadador:\n    def nadar(self):\n        print(\"Nadando\")\n\nclass Pato(Volador, Nadador):\n    def hablar(self):\n        print(\"Cuac\")\n```\n\nEsto permite usar métodos con nombres iguales en contextos distintos.\n\n---\n\n## 5. Polimorfismo con clases abstractas y métodos abstractos\n\nPython provee el módulo `abc` para definir clases abstractas y métodos que deben ser implementados por las subclases, garantizando polimorfismo.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Figura(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Triangulo(Figura):\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n    def area(self):\n        return (self.base * self.altura) / 2\n```\n\n---\n\n## 6. Ventajas del polimorfismo\n\n- Facilita la escritura de código genérico y reutilizable.\n- Permite separar la lógica de implementación del uso.\n- Fomenta la programación orientada a objetos y patrones de diseño.\n\n---\n\n## 7. Ejemplo práctico: Sistema de pago\n\n```python\nclass Pago:\n    def pagar(self, monto):\n        pass\n\nclass PagoTarjeta(Pago):\n    def pagar(self, monto):\n        print(f\"Pago con tarjeta por {monto} USD\")\n\nclass PagoPaypal(Pago):\n    def pagar(self, monto):\n        print(f\"Pago con PayPal por {monto} USD\")\n\ndef procesar_pago(metodo_pago, monto):\n    metodo_pago.pagar(monto)\n\nprocesar_pago(PagoTarjeta(), 100)\nprocesar_pago(PagoPaypal(), 150)\n```\n\nCada método de pago implementa la función `pagar`, y la función `procesar_pago` puede trabajar con cualquier tipo de pago gracias al polimorfismo.\n\n---\n\nEl polimorfismo es una herramienta esencial para crear programas robustos, mantenibles y escalables, permitiendo que distintas clases compartan interfaces comunes pero mantengan su comportamiento específico."
  },
  {
    "id": 21,
    "titulo": "Encapsulacion-Atributos-y-metodos-privados",
    "contenido": "### Encapsulación en Python: Atributos y métodos privados - Expansión detallada\n\nLa encapsulación es uno de los principios básicos de la programación orientada a objetos (POO) que se centra en ocultar los detalles internos de una clase y exponer sólo lo necesario. Esto protege el estado interno del objeto y facilita el mantenimiento y la evolución del código.\n\n---\n\n## 1. Por qué es importante la encapsulación\n\n- **Protección de datos:** Evita que los atributos sean modificados accidentalmente desde fuera.\n- **Integridad:** Garantiza que los datos sólo cambien mediante métodos controlados.\n- **Ocultamiento:** Simplifica el uso de objetos al ocultar la complejidad interna.\n- **Flexibilidad:** Permite cambiar la implementación interna sin afectar a los usuarios de la clase.\n\n---\n\n## 2. Convenciones para atributos y métodos privados\n\nPython no tiene modificadores como `private` o `protected`, pero utiliza convenciones para indicar privacidad:\n\n- **Un solo guion bajo (_):** Indica que un atributo o método es \"protegido\" y no debería usarse fuera de la clase o subclases, aunque no es una restricción real.\n- **Doble guion bajo (__):** Activa el name mangling, renombrando internamente el atributo para hacerlo menos accesible desde fuera.\n\n---\n\n## 3. Name Mangling en detalle\n\nCuando se usa doble guion bajo, Python renombra el atributo con el formato `_Clase__atributo`. Esto ayuda a evitar colisiones con atributos de subclases.\n\n```python\nclass MiClase:\n    def __init__(self):\n        self.__privado = 42\n\nobj = MiClase()\nprint(obj._MiClase__privado)  # Acceso posible pero no recomendado\n```\n\nEste mecanismo no es seguridad absoluta, sino una forma de \"ocultamiento\".\n\n---\n\n## 4. Métodos privados y su utilidad\n\nLos métodos privados encapsulan lógica interna que no debe ser expuesta ni llamada desde fuera.\n\n```python\nclass Robot:\n    def __iniciar_sistema(self):\n        print(\"Sistema iniciado\")\n\n    def arrancar(self):\n        self.__iniciar_sistema()\n        print(\"Robot en marcha\")\n```\n\nEsto permite modificar la implementación del método privado sin afectar a quien use la clase.\n\n---\n\n## 5. Uso avanzado de propiedades para encapsulación\n\nLas propiedades `@property` permiten controlar acceso a atributos con métodos getter y setter:\n\n```python\nclass Persona:\n    def __init__(self, edad):\n        self.__edad = edad\n\n    @property\n    def edad(self):\n        return self.__edad\n\n    @edad.setter\n    def edad(self, valor):\n        if valor < 0:\n            raise ValueError(\"La edad no puede ser negativa\")\n        self.__edad = valor\n```\n\nEsto garantiza validaciones automáticas en la asignación.\n\n---\n\n## 6. Encapsulación y herencia\n\nLos atributos privados con doble guion bajo no son accesibles directamente en subclases por name mangling.\n\n```python\nclass Base:\n    def __init__(self):\n        self.__privado = \"Secreto\"\n\nclass Derivada(Base):\n    def mostrar(self):\n        # print(self.__privado)  # Error\n        print(self._Base__privado)  # Acceso con name mangling\n```\n\nPara evitar problemas, a veces es mejor usar un solo guion bajo en atributos que deben ser \"protegidos\" pero accesibles por subclases.\n\n---\n\n## 7. ¿Por qué no usar siempre atributos públicos?\n\n- Permite controlar la forma en que los datos son modificados.\n- Evita estados inconsistentes del objeto.\n- Facilita la depuración y mantenimiento del código.\n\n---\n\n## 8. Ejemplo completo de encapsulación\n\n```python\nclass Banco:\n    def __init__(self, saldo):\n        self.__saldo = saldo\n\n    @property\n    def saldo(self):\n        return self.__saldo\n\n    def depositar(self, cantidad):\n        if cantidad > 0:\n            self.__saldo += cantidad\n\n    def retirar(self, cantidad):\n        if 0 < cantidad <= self.__saldo:\n            self.__saldo -= cantidad\n        else:\n            print(\"Fondos insuficientes\")\n\nbanco = Banco(1000)\nprint(banco.saldo)\nbanco.depositar(500)\nprint(banco.saldo)\nbanco.retirar(300)\nprint(banco.saldo)\n```\n\n---\n\n## 9. Resumen\n\nLa encapsulación mejora la robustez y seguridad del software, es una práctica fundamental para escribir código limpio, mantenible y escalable en Python. Usar atributos y métodos privados junto con propiedades ayuda a controlar y proteger el acceso a los datos internos de las clases."
  }
]
